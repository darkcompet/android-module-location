/*
 * Copyright (c) 2017-2021 DarkCompet. All rights reserved.
 */
package tool.compet.location

import android.location.Location
import tool.compet.location.DkLocation

/**
 * Own defined location model which does NOT dependent to model of other libraries.
 * Note: this class does not provide `LatLng` from gmap. To use it with map's LatLng,
 * consider customize new class by override this (see `tool.compet.googlemap.DkMapLocation`).
 *
 * - Refer `android.location.Location` for more useful features.
 * - Refer location description at: https://developers.google.com/maps/documentation/android-sdk/views
 */
class DkLocation {
	/**
	 * Latitude and longitude are a pair of numbers (coordinates) used to describe a position
	 * on the plane of a geographic coordinate system.
	 * The numbers are in decimal degrees format,
	 * and range [-90, 90] for latitude
	 * and range [-180, 180] for longitude.
	 *
	 * Ref: https://docs.mapbox.com/help/glossary/lat-lon/
	 */
	protected var hasLatLng = false // true when Lat & Lng were set both
	protected var lat = 0.0 // in degrees
	protected var lng = 0.0 // in degrees

	/**
	 * Altitude in meters above the WGS 84 reference ellipsoid.
	 */
	var alt = 0.0 // height (in meters) in relation to sea-level

	/**
	 * Bearing is the horizontal direction of travel of this device,
	 * and is not related to the device orientation. It is guaranteed to
	 * be in the range (0.0, 360.0] if the device has a bearing.
	 *
	 * If this location does not have a bearing then 0.0 is returned.
	 */
	var bearing = 0f // in degrees

	/**
	 * Speed in meters/second over ground.
	 */
	protected var speed = 0f // in meters/second

	/**
	 * The estimated horizontal accuracy of this location, radial, in meters.
	 *
	 * We define horizontal accuracy as the radius of 68% confidence. In other
	 * words, if you draw a circle centered at this location's
	 * latitude and longitude, and with a radius equal to the accuracy,
	 * then there is a 68% probability that the true location is inside
	 * the circle.
	 *
	 * This accuracy estimation is only concerned with horizontal
	 * accuracy, and does not indicate the accuracy of bearing,
	 * velocity or altitude if those are included in this Location.
	 *
	 * If this location does not have a horizontal accuracy, then 0.0 is returned.
	 * All locations generated by the [LocationManager] include horizontal accuracy.
	 */
	protected var accuracy = 0f
	var tilt = 0f // tilt
	var zoom = 0f // zoom level
	var resolution = 0.0 // resolution

	/**
	 * Address of this location.
	 */
	var address: String? = null

	constructor() {}
	constructor(lat: Double, lng: Double) {
		hasLatLng = true
		this.lat = lat
		this.lng = lng
	}

	fun copyFromLocation(other: Location) {
		hasLatLng = true
		lat = other.latitude
		lng = other.longitude
		alt = other.altitude
		bearing = other.bearing
		speed = other.speed
		accuracy = other.accuracy
	}

	fun copyFromPosition(lat: Double, lng: Double, bearing: Float, tilt: Float, zoom: Float) {
		hasLatLng = true
		this.lat = lat
		this.lng = lng
		this.bearing = bearing
		this.tilt = tilt
		this.zoom = zoom
	}

	fun hasLatLng(): Boolean {
		return hasLatLng
	}

	fun setLatLng(lat: Double, lng: Double) {
		hasLatLng = true
		this.lat = lat
		this.lng = lng
	}

	fun unsetLatLng() {
		hasLatLng = false
		lat = Double.NEGATIVE_INFINITY
		lng = Double.NEGATIVE_INFINITY
	}

	override fun equals(other: Any?): Boolean {
		if (this === other) {
			return true
		}
		if (other == null || other.javaClass != javaClass) {
			return false
		}
		val that = other as DkLocation
		val sameLatLng = java.lang.Double.compare(lat, that.lat) == 0 && java.lang.Double.compare(lng, that.lng) == 0
		val samePlace = address === that.address
		return sameLatLng && samePlace
	}

	override fun hashCode(): Int {
		var result = hasLatLng.hashCode()
		result = 31 * result + lat.hashCode()
		result = 31 * result + lng.hashCode()
		result = 31 * result + alt.hashCode()
		result = 31 * result + bearing.hashCode()
		result = 31 * result + speed.hashCode()
		result = 31 * result + accuracy.hashCode()
		result = 31 * result + tilt.hashCode()
		result = 31 * result + zoom.hashCode()
		result = 31 * result + resolution.hashCode()
		result = 31 * result + (address?.hashCode() ?: 0)
		return result
	}
}